<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Examples</title><link href="styles/graphSynthStyle.css" rel="stylesheet" type="text/css" /><style type="text/css"></style>
</head><body><div id="container"><div id="masthead"><a  style="border-width:0" href="http://www.engr.utexas.edu/"><img alt="UT Austin and the College of Engineering" src="images/UTCOEemblem.jpg" style="float: right" class="UT_COE_emblem" /></a> <h1>GraphSynth</h1><h5>Version 1.7</h5><h6>Software for Creating Graph Grammars<br />created by the <a href="http://www.me.utexas.edu/~adl/">Automated Design Lab</a><br />in the <a href="http://www.me.utexas.edu/">Mechanical Engineering Department</a><br />under the direction of <a href="mailto:mc1@mail.utexas.edu?subject=a question/comment about GraphSynth">Dr. Matt Campbell</a><br /></h6></div><div id="navigation"><ul><li><a href="index.htm">Home</a></li><li><a href="gettingStarted.htm">Getting Started</a></li><li><a href="introMethod.htm">Methodology Overview</a></li><li><a href="graphs.htm">Graph Basics</a></li><li><a href="grammars.htm">Grammar Basics</a></li><li><a href="rule_recognition.htm">Grammars: Recognition</a></li><li><a href="rule_application.htm">Grammars: Application</a></li><li><a href="ruleSets.htm">Grammars: Rulesets</a></li><li><a href="generation.htm">Generation</a></li><li><a href="searchProcess.htm">Search Process</a></li><li><a href="navigating.htm">Navigating GraphSynth</a></li><li><a href="examples.htm">Examples</a></li><li><a href="download.htm">Download</a></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p></div><div id="content"><h2>Examples</h2><p>Four examples are provided in the GraphSynth download, and more will be available soon for more complicated (albeit mechanical engineering) applications. </p><h3>Swirl</h3><p>Files: <br />input/swirlSeed1.xml <br />rules/swirlRuleSet.xml <br />rules/swirlRule1.xml rules/swirlVertices.cs <br />output/candidate00#.xml <br /><br />Swirl is a simple 1 rule system. That makes counter-clockwise patterns from either end of a simple seed. The magic of this is found primarily in the parametric rule application that updates the position of vertices (not nodes! this is also an example of how inherited classes can be used) by increasing the edge slope and the edge length. </p><h3>Loop </h3><p>Files: <br />input/loopSeed1.xml <br />rules/loopExampleRuleSet.xml <br />rules/loopRule1.xml output/looped.xml <br /><br />Loop is also a 1 rule system. The rule expands an existing loop and wreaks havoc on the direction of the arcs. This example is mainly to show the use of embedding rules. Note that this works despite the lack of commonality between the left and right hand sides of the rule. </p><h3>SeedBurst </h3><p>Files: <br />input/seedBurst1.xml <br />rules/seedBurst5rule1.xml <br />rules/seedBurst3rule2.xml <br />rules/seedBurst2rule3.xml <br />rules/seedBurst1rule4.xml <br />rules/seedBurstRuleSet.xml <br />output/29burst.xml <br />output/35burst.xml <br /><br />SeedBurst is an interesting example of both parametric recognize and choose functions. Given a seed that is a single node, the four rules of SeedBurst create a unique tree for the integer where each leaf of the tree is represented with a value of “1”. One additional thing to notice about this system, is that the rule set is Automatic and not Design (see description on <a href="ruleSets.htm">rule set page</a>). </p><h3>Route </h3><p>Files: <br />input/citiesDefaultSeedGraph.xml <br />input/MajorUSAcities.xml <br />rules/Routerule1.xml <br />rules/Routerule2.xml <br />rules/Routerule3.xml <br />rules/RouteGetToSpanningRuleSet.xml<br />rules/RouteGetToCompleteRuleSet.xml <br />output/MST5cities.xml <br /><br />Route is an example of how more than one rule set can work together to create a candidate solution. Here, the first rule set transitions the graph from just a list of unconnected nodes to a spanning tree (the minimum spanning tree is easily identified with Prim’s or Kruskal’s algorithm which could be implemented in an intelligent choosing function—that minimum spanning tree is shown in the output directory). Afterwards, we would like to add additional routes between cities for convenience in traveling from any location to any other location. The two rule sets will create a random candidate—”you’re free to move about the country”. </p></div><div id="footer"><p><a href="index.htm">Home</a> | <a href="gettingStarted.htm">Getting Started</a> | <a href="introMethod.htm">Methodology Overview</a> | <a href="graphs.htm">Graph Basics</a> | <a href="grammars.htm">Grammar Basics</a> | <a href="rule_recognition.htm">Grammars: Recognition</a> | <a href="rule_application.htm">Grammars: Application</a> | <a href="ruleSets.htm">Grammars: Rulesets</a> | <a href="generation.htm">Generation</a> | <a href="searchProcess.htm">Search Process</a> | <a href="navigating.htm">Navigating GraphSynth</a> | <a href="examples.htm">Examples</a> | <a href="download.htm">Download</a></p></div><div class="bottomLegalities"><br /><br /><br />© 2007, the <a href="http://www.me.utexas.edu/~adl/">Automated Design Laboratory</a>,&nbsp; <a href="http://www.me.utexas.edu/">Mechanical Engineering Department</a> of the <a href="http://www.engr.utexas.edu/">College of Engineering</a> at the <a href="http://www.utexas.edu/">University of Texas at Austin</a>. <br />All rights reserved. This page was last updated on Wednesday, July 4, 2007 by the <a href="mailto:mc1@mail.utexas.edu">Dr. Matt Campbell</a>. </div></div></body></html>