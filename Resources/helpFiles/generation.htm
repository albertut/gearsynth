<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Generation</title><style type="text/css">
.style1 {
	margin-top: 0;
	margin-bottom: 1px;
	font-family: "Courier New", Courier, monospace;
	font-weight: bold;
	font-style: italic;
	color: #008080;
}
.style2 {
	margin-top: 0;
	margin-bottom: 1px;
	font-family: "Courier New", Courier, monospace;
	font-weight: bold;
	font-style: italic;
	color: #0000FF;
}
</style>
<link href="styles/graphSynthStyle.css" rel="stylesheet" type="text/css" /><style type="text/css"></style>
</head><body><div id="container"><div id="masthead"><a  style="border-width:0" href="http://www.engr.utexas.edu/"><img alt="UT Austin and the College of Engineering" src="images/UTCOEemblem.jpg" style="float: right" class="UT_COE_emblem" /></a> <h1>GraphSynth</h1><h5>Version 1.7</h5><h6>Software for Creating Graph Grammars<br />created by the <a href="http://www.me.utexas.edu/~adl/">Automated Design Lab</a><br />in the <a href="http://www.me.utexas.edu/">Mechanical Engineering Department</a><br />under the direction of <a href="mailto:mc1@mail.utexas.edu?subject=a question/comment about GraphSynth">Dr. Matt Campbell</a><br /></h6></div><div id="navigation"><ul><li><a href="index.htm">Home</a></li><li><a href="gettingStarted.htm">Getting Started</a></li><li><a href="introMethod.htm">Methodology Overview</a></li><li><a href="graphs.htm">Graph Basics</a></li><li><a href="grammars.htm">Grammar Basics</a></li><li><a href="rule_recognition.htm">Grammars: Recognition</a></li><li><a href="rule_application.htm">Grammars: Application</a></li><li><a href="ruleSets.htm">Grammars: Rulesets</a></li><li><a href="generation.htm">Generation</a></li><li><a href="searchProcess.htm">Search Process</a></li><li><a href="navigating.htm">Navigating GraphSynth</a></li><li><a href="examples.htm">Examples</a></li><li><a href="download.htm">Download</a></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p></div><div id="content"><h2>Generation</h2><p>We consider the seed graph, the grammar rules and the rule sets to provide the designer with the Representation for a particular problem domain. On top of this representation, GraphSynth provides us the basic framework to generate candidate solutions through a recognize, choose and apply cycle shown here. </p><p class="figure" style="left: 450px; top: 339px; width: 318px"><img src="images/generationProcess.png" width="318" height="679" alt="Figure 1: Throughout a recognize, choose, and apply generation process, any of five things may happen. In order to plan accordingly a rule set should include instructions for how to handle each of these possible exits." /><br />Figure 1: Throughout a recognize, choose, and apply generation process, any of five things may happen. In order to plan accordingly a rule set should include instructions for how to handle each of these possible exits. </p><p style="width: 273px">The code for this particular generation function is found in the 2.Generation directory under the filename RecognizeChooseApply.cs. This is actually an abstract class and cannot be invoked directly, as a result on must produce an inherited class to use this function. Two such inherited classes are shown in that same directory: chooseViaHumanGui.cs and randomChoose.cs. Mainly these inherited classes answer a difficult question of graph synthesis: how or who will make the decisions to synthesize new graphs? </p><p style="width: 279px">Once an inherited class is established, a creation of that class (constructor) will be required to populate the fields of the recognize, choose, and apply process. These fields are: </p><p style="width: 280px"><span class="style2">int[]</span><span class="codeInText"> maxNumOfCalls</span> :&nbsp; the number of calls or cycles specified for each rule set. This is an array of length specified by the number of rule sets. <br />If it is not set, the value of <span class="codeInText">maxRulesToApply </span>will be used.</p><p style="width: 280px"><span class="style1">candidate</span><span class="codeInText"> seed</span> :&nbsp; Often the same seed is used as a starting point with the generation process. That seed is stored here as a global field of the class. </p><p style="width: 280px"><span class="style2">ruleSet[]</span><span class="codeInText"> rulesets</span> : The ruleSet array used to perform the generation process is stored here. </p><p><span class="style2">Boolean </span><span class="codeInText">display </span>: A simple Boolean used for debugging or interactive generation. If true then the host will be re-plotted after each apply action. </p><p>After the creation of the generation methods, one can invoke the generation by calling one of the existing RecognizeChooseApply.cs invoked functions: </p><p class="codeSnippet"><span class="blueCode">public </span><span class="tealCode">candidate </span>generateOneCandidate()<br /><span class="blueCode">public void </span>runGUIOrRandomTest()<br /><span class="blueCode">public </span><span class="tealCode">candidate</span>[] GenerateArrayOfCandidates(<span class="blueCode">int</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numToCandidates)<br /><span class="blueCode">public </span><span class="tealCode">List</span>&lt;<span class="tealCode">candidate</span>&gt; GenerateListOfCandidates(<span class="blueCode">int</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numToCandidates) </p><p>or by writing your own invoking function in the derived class (see example at bottom of randomChoose.cs).</p></div><div id="footer"><p><a href="index.htm">Home</a> | <a href="gettingStarted.htm">Getting Started</a> | <a href="introMethod.htm">Methodology Overview</a> | <a href="graphs.htm">Graph Basics</a> | <a href="grammars.htm">Grammar Basics</a> | <a href="rule_recognition.htm">Grammars: Recognition</a> | <a href="rule_application.htm">Grammars: Application</a> | <a href="ruleSets.htm">Grammars: Rulesets</a> | <a href="generation.htm">Generation</a> | <a href="searchProcess.htm">Search Process</a> | <a href="navigating.htm">Navigating GraphSynth</a> | <a href="examples.htm">Examples</a> | <a href="download.htm">Download</a></p></div><div class="bottomLegalities"><br /><br /><br />Â© 2007, the <a href="http://www.me.utexas.edu/~adl/">Automated Design Laboratory</a>,&nbsp; <a href="http://www.me.utexas.edu/">Mechanical Engineering Department</a> of the <a href="http://www.engr.utexas.edu/">College of Engineering</a> at the <a href="http://www.utexas.edu/">University of Texas at Austin</a>. <br />All rights reserved. This page was last updated on Wednesday, July 4, 2007 by the <a href="mailto:mc1@mail.utexas.edu">Dr. Matt Campbell</a>. </div></div></body></html>