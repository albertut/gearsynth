<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Grammars: Managing Rulesets</title><link href="styles/graphSynthStyle.css" rel="stylesheet" type="text/css" /><style type="text/css"></style>
</head><body><div id="container"><div id="masthead"><a  style="border-width:0" href="http://www.engr.utexas.edu/"><img alt="UT Austin and the College of Engineering" src="images/UTCOEemblem.jpg" style="float: right" class="UT_COE_emblem" /></a> <h1>GraphSynth</h1><h5>Version 1.7</h5><h6>Software for Creating Graph Grammars<br />created by the <a href="http://www.me.utexas.edu/~adl/">Automated Design Lab</a><br />in the <a href="http://www.me.utexas.edu/">Mechanical Engineering Department</a><br />under the direction of <a href="mailto:mc1@mail.utexas.edu?subject=a question/comment about GraphSynth">Dr. Matt Campbell</a><br /></h6></div><div id="navigation"><ul><li><a href="index.htm">Home</a></li><li><a href="gettingStarted.htm">Getting Started</a></li><li><a href="introMethod.htm">Methodology Overview</a></li><li><a href="graphs.htm">Graph Basics</a></li><li><a href="grammars.htm">Grammar Basics</a></li><li><a href="rule_recognition.htm">Grammars: Recognition</a></li><li><a href="rule_application.htm">Grammars: Application</a></li><li><a href="ruleSets.htm">Grammars: Rulesets</a></li><li><a href="generation.htm">Generation</a></li><li><a href="searchProcess.htm">Search Process</a></li><li><a href="navigating.htm">Navigating GraphSynth</a></li><li><a href="examples.htm">Examples</a></li><li><a href="download.htm">Download</a></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p></div><div id="content"><h2>Grammars: Managing<br />Rulesets</h2><p style="width: 256px">Grammar rules are organized into sets, simply called rule sets. These are stored in compact XML files that contain references to each of the grammar rules in the set. All of the details of the rule set can be configured through GraphSynth’s ruleSetDisplay — there is no need to open a ruleset’s XML in an editor (I have only ever done it out of curiosity!). </p><p style="width: 259px">The top of the pane is a list of the rules added to set. Any number of rules may be added to a rule set by clicking the add rule button. Once rules are in the set their order can be rearranged or they can be subsequently deleted. Along the bottom are three buttons that indicates what to do with the checked rules listed above. The checked rules are deleted by the “del” button, or moved up or down (“dn”) in the list. <br /></p><p class="figure" style="left: 437px; top: 229px"><img alt="example ruleset from the seedBurst example" src="images/seedBurstRuleSet.png" width="281" height="498" /></p><p>Following the list of rules is a list of important rule set properties. Similar to graphs and grammar rules the name will simply be inherited from the filename, and is not internally used within GraphSynth. The next is a property called “triggerRule #.” A trigger rule is one that when invoked during the generation process causes a particular action to occur. Currently, only one triggerRule can be set per rule set. If there is no intention to use the trigger rule,&nbsp; then the item should be set to –1. The triggerRule # corresponds to the rule # shown in the top pane. </p><p>The next seven properties deal with how the rule set behaves during <a href="generation.htm">Generation</a> (It is recommended that this section is well understood before proceeding with this description). The “choiceMethod” is set to either Automatic or Design. An automatic rule set is one that will invoke the rule once it is recognized. This is the case in the example to the right (the example seedBurstRuleSet in the rules directory). When a rule set is set to Automatic, the random tests and user choose tests under the design drop down will not function. This is because the rules fire immediately, skipping the choose part of the generation cycle. Given the methodical approach followed by recognize, we will get the same resulting graph every time with an Automatic ruleset. It will first look for valid locations of the first rule and searching in the host from the first listed nodes on down. This continues for the remaining rules. The important thing to note in automatic rule sets is that latter rules will not be invoked unless all previous rules were unrecognized. This is illustrated well in the seedBurst example. Alternatively, if one knows that their rule set is confluent, then an automatic rule set will work as expected.</p><p>“<span class="codeInText">Interim Candidates are</span>” &amp; “<span class="codeInText">Final Candidates are</span>” are properties developed to support latter automated <a href="searchProcess.htm">searching of graphs</a>. Often grammars rule sets are created so that only after all rules are invoked is a feasible solution achieved. For such rule sets, we would indicate that Interim Candidates are Developing and Final Candidates are Feasible—as is the case for the seedBurst example shown above. However, in other examples such as the fun swirlSeed example. We set both to Feasible. Users may want to create choosing methods that check these qualities to know if a candidate is complete and subsequent rules are simply modifying it, or if the candidate is Developing towards a Feasible candidate. </p><p>The next five properties correspond to the five ways that the Recognize<span class="inlineArialArrow">→</span>Choose<span class="inlineArialArrow">→</span>Apply generation cycle may end (see <a href="generation.htm">Generation</a>). These each can be set to one of the five actions:<br /><span class="codeInText">Stop </span>: simply end the generation process,<br /><span class="codeInText">Loop </span>: restart Recognize<span class="inlineArialArrow">→</span>Choose<span class="inlineArialArrow">→</span>Apply,<br /><span class="codeInText">GoToPrevious </span>: go to the previous rule set stored in the array <span class="codeInText">Program.rulesets</span>[],<br /><span class="codeInText">GoToNext </span>: go to the next rule set,<br /><span class="codeInText">GoToRuleSet#n</span> : go to rule set #n.</p><p>As a result of setting these five properties to any of these five actions, we can greatly control how the rule sets execute. Note that there may be any number of rule sets within a particular synthesis of a graph. We have noticed on several occasions that grammar rule are stored in sets that perform different actions within the overall synthesis. An example of multiple rule sets can be found in the Routes example (RouteGetToSpanningRuleSet.xml and RouteGetToCompleteRuleSet.xml in the rules directory). After the first rule set has run out of rules, then we know that we have created a spanning tree of the nodes in the seed graph (citiesDefaultSeedGraph.xml). Since “NoRules” is set to <span class="codeInText">GoToNext</span>, the next rule set is invoked to add additional routes between the cities. </p><p>Finally, the rule set has properties that list the filenames for recognize or apply parametric functions. These need to be established prior to creating templates for functions in the <a href="grammars.htm">grammar rule</a> property window. As is shown in the examples, a “.cs” file has been created for each ruleset. Each of these files contains all the functions used by that ruleset. This is not enforced by GraphSynth though. One may have multiple “.cs” files for a ruleset or multiple rulesets referencing the same source file. </p><p>Note: Because rule sets are stored in a fixed array <br />(<span class="codeInText">Program.rulesets</span>[]), please specify the number in advance in the settings (<span class="codeInText">GraphSynthSettings.config</span>). </p></div><div id="footer"><p><a href="index.htm">Home</a> | <a href="gettingStarted.htm">Getting Started</a> | <a href="introMethod.htm">Methodology Overview</a> | <a href="graphs.htm">Graph Basics</a> | <a href="grammars.htm">Grammar Basics</a> | <a href="rule_recognition.htm">Grammars: Recognition</a> | <a href="rule_application.htm">Grammars: Application</a> | <a href="ruleSets.htm">Grammars: Rulesets</a> | <a href="generation.htm">Generation</a> | <a href="searchProcess.htm">Search Process</a> | <a href="navigating.htm">Navigating GraphSynth</a> | <a href="examples.htm">Examples</a> | <a href="download.htm">Download</a></p></div><div class="bottomLegalities"><br /><br /><br />© 2007, the <a href="http://www.me.utexas.edu/~adl/">Automated Design Laboratory</a>,&nbsp; <a href="http://www.me.utexas.edu/">Mechanical Engineering Department</a> of the <a href="http://www.engr.utexas.edu/">College of Engineering</a> at the <a href="http://www.utexas.edu/">University of Texas at Austin</a>. <br />All rights reserved. This page was last updated on Wednesday, July 4, 2007 by the <a href="mailto:mc1@mail.utexas.edu">Dr. Matt Campbell</a>. </div></div></body></html>