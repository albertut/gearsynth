<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Search Process</title><style type="text/css">
.style3 {
	color: #FF0000;
}
</style>
<link href="styles/graphSynthStyle.css" rel="stylesheet" type="text/css" /><style type="text/css"></style>
</head><body><div id="container"><div id="masthead"><a  style="border-width:0" href="http://www.engr.utexas.edu/"><img alt="UT Austin and the College of Engineering" src="images/UTCOEemblem.jpg" style="float: right" class="UT_COE_emblem" /></a> <h1>GraphSynth</h1><h5>Version 1.7</h5><h6>Software for Creating Graph Grammars<br />created by the <a href="http://www.me.utexas.edu/~adl/">Automated Design Lab</a><br />in the <a href="http://www.me.utexas.edu/">Mechanical Engineering Department</a><br />under the direction of <a href="mailto:mc1@mail.utexas.edu?subject=a question/comment about GraphSynth">Dr. Matt Campbell</a><br /></h6></div><div id="navigation"><ul><li><a href="index.htm">Home</a></li><li><a href="gettingStarted.htm">Getting Started</a></li><li><a href="introMethod.htm">Methodology Overview</a></li><li><a href="graphs.htm">Graph Basics</a></li><li><a href="grammars.htm">Grammar Basics</a></li><li><a href="rule_recognition.htm">Grammars: Recognition</a></li><li><a href="rule_application.htm">Grammars: Application</a></li><li><a href="ruleSets.htm">Grammars: Rulesets</a></li><li><a href="generation.htm">Generation</a></li><li><a href="searchProcess.htm">Search Process</a></li><li><a href="navigating.htm">Navigating GraphSynth</a></li><li><a href="examples.htm">Examples</a></li><li><a href="download.htm">Download</a></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p></div><div id="content"><h2>Search Process</h2><p class="figure" style="left: 428px; top: 203px"><img src="images/designDropDown.png" width="354" height="269" alt="Drop-down menu items for the design window. " /><br />Figure 1: Drop-down menu items for the design window. </p><p style="width: 249px">The Design drop down menu in GraphSynth provides functions to test and synthesize new graphs from the grammar rule sets described in earlier pages (<a href="graphs.htm">graphs</a>, <a href="grammars.htm">grammars</a>, <a href="ruleSets.htm">rule sets</a>). Firstly, the pane has commands to set the active seed and the first three active rule sets. These can also be set in the GraphSynthSettings.config file, through the settings drop-down under File,&nbsp; so that they are</p><p >established on beginning the program (this proves to be a great time-saver!). The GUI will only allow one to assign the first three rule sets; however, if you want more, you will need to make the assignments in GraphSynthSettings.config or even during <span class="codeInText">Program.runSearchProcess</span>(). </p><p>This is followed by the “Run Search Process” item, which is the main entry point for a search process that one may implement (more on this in a second). The bottom three items allow for the testing or rules, rule sets, and seeds. The “Recognize<span class="inlineArialArrow">→</span>User Choose<span class="inlineArialArrow">→</span>Apply” item invokes a dialog to choose the rules by hand. Within the options presented in that dialog, one can double-click a location to see what subgraph the rule is applying to. The “Recognize<span class="inlineArialArrow">→</span>Random Choose<span class="inlineArialArrow">→</span>Apply” item will continuously call random options on the seed until the process stops (stops by encountering a “Stop” in one of the <a href="generation.htm">5 generation exits</a>). Additionally the gray box that is labeled “#steps” can be changed to a set a integers that will be assigned to the generation cycle limits for each rule set (see <a href="generation.htm">int[] maxNumOfCalls</a>). For example by replacing “#steps” with “4, 5 12”, the generation process will be invoked with set <span class="codeInText">maxNumOfCalls </span>to [4, 5, 12] (most common separators such as comma and space can be used). </p><h3>Search Process Controller</h3><p style="width: 388px">When any of these lower items are clicked, a small controller window appears (often it is hidden for user and random testing). The controller allows one to change how the search process is executing. The snapshot to the right was taken while the process was executing. Notice that the “Play” button is disabled since the process is already in operation. The process can be paused, stopped , or aborted from this point. Pressing the “Stop” button will send a request to the process. This is to allow the process to end and still retain useful results. It will not always function if the search process is using the computational resources elsewhere. Thus as a last resort, the “Abort” button will attempt to kill the thread that the search process is running on. </p><p class="figure" style="left: 562px; top: 961px; width: 232px"><img src="images/searchProcessController.png" width="232" height="178" alt="The Search Process Controller allows on to dynamically control aspects of the search process. It is inspired by the transport bar of computer music applications. " /><br />Figure 2: The Search Process Controller allows on to dynamically control aspects of the search process. It is inspired by the transport bar of <a href="http://en.wikipedia.org/wiki/Cubase" class="style2"><span class="style3">computer music applications.</span></a> </p><p>In addition to these button, there are three displays that show pertinent information about the process. The time is implemented as part of the controller; it ‘pings’ the thread the search process is on in specific intervals. The rate at which it pings is based on the verbosity setting (described below). The top two displays shown the iterations and a miscellaneous field. These are set in the search process by setting the <span class="codeInText">iteration </span>and <span class="codeInText">miscObject </span>properties of the main Program.cs. At the bottom one can set the priority and verbosity for the search process. The computational processes in GraphSynth run on separate threads, and a thread can be given a priority over other threads. Set this high if you want to speed up the process but do not mind it slowly down other processes including the main thread (thus making GraphSynth appear as if it has locked up!). The verbosity is a highly useful UI that allows the user to adjust how much text is being output by the process. One is encouraged to implement many <span class="boldTealPseudoCode"><em>SearchIO</em></span><span class="codeInText">.output </span>statements in a search process to provide information about the progress of a long operation. However, such commands can greatly slow down the processing. By dynamically setting how verbose we want the search process to be, we can get the information we want when we need it. </p><p style="width: 429px">The <span class="boldTealPseudoCode"><em>SearchIO</em></span><span class="codeInText">.output </span>function can be invoked with an object (usually a string) to print and a verbosity limit, which is an integer from 0 to 4. If the verbosity limit is set to 0, then the object will be printed all the time even for verbosity set to “lowest.” If it is set to 4, then it will only print when verbosity is set to “highest.” </p><h3>Writing a Custom Search Process </h3><p class="figure" style="left: 600px; top: 1626px; width: 262px"><img alt="Figure 3: The Representation is accomplished by the seed, and rule set; and the Generation by the R-&gt;C-&gt;A cycle. What remains in the search process is some method to evaluate the quality of candidate graphs (classes and functions to be stored in 3.Evaluation), and methods to learn from these results to improve the next generation (classes and functions to be stored in 4.Guidance). &nbsp;" src="images/flowchart.png" width="262" height="481" /><br />Figure 3: The Representation is accomplished by the seed, and rule set; and the Generation by the R<span class="inlineArialArrow">→</span>C<span class="inlineArialArrow">→</span>A cycle. What remains in the search process is some method to evaluate the quality of candidate graphs (classes and functions to be stored in Evaluation), and methods to learn from these results to improve the next generation (classes and functions to be stored in Guidance). &nbsp; </p><p style="width: 429px">As discussed in the introduction, one may want to automate the creation of candidate solutions. This custom code can be written in under the function <span class="boldTealPseudoCode"><em>Program</em></span><span class="codeInText">.runSearchProcess()</span> in the file searchProcess.cs. In fact, any C# code can be written here. One may want to invoke functions or classes from another Visual Studio project, or invoke additionally GUI forms. &nbsp; In the example code, the swirl seed and rule set are loaded (which encapsulates the <span class="boldTealPseudoCode">representation</span>) , and we create the <span class="boldTealPseudoCode">generate</span>, <span class="boldTealPseudoCode">evaluate </span>and <span class="boldTealPseudoCode">guide </span>methods for the search process:&nbsp; </p><p class="codeSnippet" style="width: 400px; border-left:0px">Generation.<span class="tealCode">randomChoose </span>GenerationApproach<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = <span class="blueCode">new </span>Generation.<span class="tealCode">randomChoose<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(<span class="tealCode">Program</span>.seed, <span class="tealCode">Program</span>.rulesets,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="blueCode">new int[1]</span> { 50 }, <span class="blueCode">false</span>); <br />Evaluation.<span class="tealCode">EvaluateSwirls </span>EvaluationApproach<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = <span class="blueCode">new </span>Evaluation.<span class="tealCode">EvaluateSwirls</span>(); Guidance.<span class="tealCode">DoNothingButDisplay </span>GuidanceApproach <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = newGuidance.<span class="tealCode">DoNothingButDisplay</span>(); </p><p>The initiation of these routines is done at the begin-<br />ning of the process in an attempt to make GraphSynth <br />modular for a wide range of applications. Throughout the <br />search process, one can take advantage of a number of fields <br />in the <span class="boldTealPseudoCode"><em>Program</em> </span>and <span class="boldTealPseudoCode"><em>SearchIO</em> </span>cclasses. These are listed below for your reference: </p><p><span class="boldTealPseudoCode"><em>Program</em></span><span class="codeInText">.settings</span> : The class <span class="boldTealPseudoCode">globalSettings </span>is in the Application_UI_and_Search directory. These values are loaded in from the GraphSynthSettings.config file. </p><p><span class="boldTealPseudoCode"><em>Program</em></span><span class="codeInText">.mainForm</span> :&nbsp; &nbsp;this is the reference to the mainForm - the top/largest GraphSynth Window. It may be difficult to reference objects from a search process, as Visual Studio will view this as a cross threading operation (which apparently is a bad thing. See the SafeInvokeHelper class in Represenation<span class="inlineArialArrow">→</span>XMLandIO for a solution) </p><p><span class="boldTealPseudoCode"><em>Program</em></span><span class="codeInText">.seed</span> : This is the seed graph (of class <span class="tealCode">designGraph</span>) indicated by the &quot;Set Active as Seed&quot; drop-down on the Design menu item or through the settings. It represents the top of the search tree.</p><p><span class="boldTealPseudoCode"><em>Program</em></span><span class="codeInText">.rulesets</span> : An array of class <span class="tealCode">ruleSet </span>of length <span class="tealCode">Program</span>.settings.numOfRuleSets. These can be set in the same manner as <span class="tealCode">Program</span>.seed. </p><p><em>(The following can be called from either static class </em><span class="tealCode"><em>SearchIO </em></span><em>or </em><span class="tealCode"><em>Program</em></span><em>. Anything written in the searchProcess.cs file will likely already be in the Program class and the property may be reached without specifying the class. However, if you are in another project (i.e. within Evaluate) you will need to use </em><span class="tealCode"><em>SearchIO </em></span><em>prefix, as you will not be able to see the </em><span class="tealCode"><em>Program </em></span><em>class.) </em></p><p><span class="boldTealPseudoCode"><em>SearchIO</em></span><span class="codeInText">.output </span>or <span class="boldTealPseudoCode"><em>Program</em></span><span class="codeInText">.output</span> : Use the various overloads of this statement to print messages to the sidebar text in the main form of GraphSynth. While a <span class="codeInText">verbosityLimit </span>is not mandatory, it is a &quot;nice to have&quot;, take the time to put something here. </p><p><em><span class="boldTealPseudoCode">SearchIO</span></em><span class="codeInText">.processNum</span> or <span class="boldTealPseudoCode"><em>Program</em></span><span class="codeInText">.processNum</span> : A read-only integer that simply lists what search process one is currently on. Not really that useful, during search process. The integer simply increments for each new search started in a single run of GraphSynth.</p><p><span class="boldTealPseudoCode"><em>SearchIO</em></span><span class="codeInText">.terminateRequest</span> or <span class="boldTealPseudoCode"><em>Program</em></span><span class="codeInText">.terminateRequest</span> : A read-only Boolean that indicates true when the user has clicked the stop button on the SearchProcessController. </p><p><span class="boldTealPseudoCode"><em>SearchIO</em></span><span class="codeInText">.timeInterval</span> or <span class="boldTealPseudoCode"><em>Program</em></span><span class="codeInText">.timeInterval</span> : A read-only TimeSpan (a fundamental C# class)object that indicates how long the search has been going on. </p><p><span class="boldTealPseudoCode"><em>SearchIO</em></span><span class="codeInText">.iteration</span> or <span class="boldTealPseudoCode"><em>Program</em></span><span class="codeInText">.iteration</span> : The number of iterations that have occured in the process. It can be read or set using this. The SearchProcessController will reflect the value in the first box. <em>NOTE: Setting this value through <span class="boldTealPseudoCode">Program</span><span class="codeInText">.iteration </span>causes an immediate update of the SearchProcessController. This is either a good thing or a bad thing. You will see immediately when the iteration changes, but if it is happening a lot then it may slow down your process.</em></p><p><span class="boldTealPseudoCode"><em>SearchIO</em></span><span class="codeInText">.miscObject</span> or <span class="boldTealPseudoCode"><em>Program</em></span><span class="codeInText">.miscObject</span>: Any object that the researcher wants to store. It will be converted to a string and shown in the SearchProcessController.&nbsp; <em>NOTE: Setting this value through <span class="boldTealPseudoCode">Program</span><span class="codeInText">.miscObject</span> causes an immediate update of the SearchProcessController. This is either a good thing or a bad thing. You will see immediately when the iteration changes, but if it is happening a lot then it may slow down your process.</em></p></div><div id="footer"><p><a href="index.htm">Home</a> | <a href="gettingStarted.htm">Getting Started</a> | <a href="introMethod.htm">Methodology Overview</a> | <a href="graphs.htm">Graph Basics</a> | <a href="grammars.htm">Grammar Basics</a> | <a href="rule_recognition.htm">Grammars: Recognition</a> | <a href="rule_application.htm">Grammars: Application</a> | <a href="ruleSets.htm">Grammars: Rulesets</a> | <a href="generation.htm">Generation</a> | <a href="searchProcess.htm">Search Process</a> | <a href="navigating.htm">Navigating GraphSynth</a> | <a href="examples.htm">Examples</a> | <a href="download.htm">Download</a></p></div><div class="bottomLegalities"><br /><br /><br />© 2007, the <a href="http://www.me.utexas.edu/~adl/">Automated Design Laboratory</a>,&nbsp; <a href="http://www.me.utexas.edu/">Mechanical Engineering Department</a> of the <a href="http://www.engr.utexas.edu/">College of Engineering</a> at the <a href="http://www.utexas.edu/">University of Texas at Austin</a>. <br />All rights reserved. This page was last updated on Wednesday, July 4, 2007 by the <a href="mailto:mc1@mail.utexas.edu">Dr. Matt Campbell</a>. </div></div></body></html>